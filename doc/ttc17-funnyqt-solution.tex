\documentclass[a4paper]{article}
\usepackage{onecolceurws}

\usepackage[T1]{fontenc}
\usepackage{varioref}
\usepackage{hyperref}

\usepackage{url}
\usepackage{paralist}
\usepackage{graphicx}
\usepackage{todonotes}

\usepackage{relsize}
\usepackage[cache]{minted}
\setminted{fontsize=\fontsize{8}{8},breaklines=true,breakbytoken=true,autogobble,numbersep=3pt,numberblanklines=false}
\setmintedinline{fontsize=\relscale{.9},breaklines=true,breakbytoken=true}
\newminted{clojure}{}
\newmintinline{clojure}{}
\newcommand{\code}{\clojureinline}
\VerbatimFootnotes

\title{Solving the TTC Families to Persons Case with FunnyQT}
\author{Tassilo Horn\\ \href{mailto:tsdh@gnu.org}{tsdh@gnu.org}}
\institution{The GNU Project}

\begin{document}
\maketitle

\begin{abstract}
  This paper describes the FunnyQT solution to the TTC 2017 Families to Persons
  bidirectional transformation case.  The solution passes all batch
  transformation tests and some of the incremental tests.
\end{abstract}


\section{Introduction}
\label{sec:introduction}

This paper describes the FunnyQT\footnote{\url{http://funnyqt.org}}
~\cite{diss,funnyqt-icgt15} solution of the TTC 2017 Families to Persons
case~\cite{f2p-case-desc}.  With only 49 lines of declarative code, the
solution is able to pass all batch transformation tests and some of the
incremental tests.

The solution project is available on
Github\footnote{\url{https://github.com/tsdh/ttc17-families2persons-bx}}.

\todo[inline]{What about SHARE???}

FunnyQT is a model querying and transformation library for the functional Lisp
dialect Clojure\footnote{\url{http://clojure.org}}.  Queries and
transformations are Clojure programs using the features provided by the FunnyQT
API.

Clojure provides strong metaprogramming capabilities that are used by FunnyQT
in order to define several \emph{embedded domain-specific languages} (DSL) for
different querying and transformation tasks.

FunnyQT is designed with extensibility in mind.  By default, it supports
EMF~\cite{Steinberg2008EEM} and
JGraLab~\footnote{\url{https://github.com/jgralab/jgralab}} TGraph models.
Support for other modeling frameworks can be added without having to touch
FunnyQT's internals.

The FunnyQT API is structured into several namespaces, each namespace providing
constructs supporting concrete querying and transformation use-cases, e.g.,
model management, functional querying, polymorphic functions, relational
querying, pattern matching, in-place transformations, out-place
transformations, bidirectional transformations, and some more.  For solving the
families to persons case, its bidirectional transformation and relational model
querying DSLs have been used.


\section{Solution Description}
\label{sec:solution-description}

This section explains the FunnyQT solution.  First,
section~\ref{sec:bidi-intro} introduces the basic syntax and semantics of its
embedded bidirectional transformation DSL.  Thereafter, \ref{sec:f2p-solution}
explains the actual transformation solving the case.  Lastly, \ref{sec:gluing}
explains how the solution is integrated into the \emph{benchmarx} framework.


\subsection{FunnyQT's Bidirectional Transformation DSL}
\label{sec:bidi-intro}

FunnyQT's bidirectional transformation DSL is based on its relational model
querying DSL which in turn is based on the Clojure port of
\emph{miniKanren}\footnote{\url{http://minikanren.org/}} which is called
\emph{core.logic}\footnote{\url{https://github.com/clojure/core.logic}}.
FunnyQT is able to generate a relational querying API for a given metamodel.
Using that, a custom relation like the following can be written.  In there, the
namespace alias \code|ccl/| denotes \emph{core.logic} constructs and the alias
\code|f/| denotes relations generated by FunnyQT.

\begin{clojurecode}
(defn same-named-mother-and-childo [f family mother child name]
  (ccl/all
   (f/Family f family)
   (f/->mother f family mother)
   (f/name f mother name)
   (ccl/conde
    [(f/->daughters f family child)]
    [(f/->sons f family child)])
   (f/name f child name)))
\end{clojurecode}

A relation like \code|same-named-mother-and-childo|\footnote{As miniKanren was
  originally implemented for Scheme which doesn't require a namespace system,
  it has become a convention to suffix relations with ``o'' to disambiguate
  them from functions.} is defined as a plain function with a name and a
argument vector.  By convention, all generated relations require the model
being queried as first argument, i.e., \code|f| denotes a family model.  The
relation describes a \code|family| with a \code|mother| having some
\code|name|.  Additionally, the \code|family| has a daughter or
son\footnote{\clojureinline|ccl/conde| is a disjunction where both clauses may
  succeed.} \code|child| which happens to have the same \code|name| as the
mother.

An application of such a relation (called a \emph{goal}) delivers all possible
solutions, i.e., all tuples of a family, its mother, a child of the family, and
a name which is the name of both mother and child.  Any parameter can be both
input and output.  If it is \emph{fresh} (not bound already), it'll be bound to
every possible solution one after the other.  If it is \emph{ground} (already
bound to some concrete value), it restricts the sequence of possible solutions
of the remaining fresh variables.

\bigskip{}

Based on the relational model querying API described above, FunnyQT provides a
bidirectional transformation DSL.  A bidirectional transformation is defined
with the \code|bx/deftransformation|\footnote{In all listings, the namespace
  alias \code|bx| prefixes constructs from FunnyQTs bidirectional
  transformation namespace.} macro, it has a name, and an argument vector.

\begin{clojurecode}
(bx/deftransformation something2anything [st at]
  ;; t-relations...
  )
\end{clojurecode}

The first and second argument always denote the models the transformation
handles.  In the example, we say that \code|st| is the \emph{left} model and
\code|at| is the \emph{right} model\footnote{For a truly bidirectional
  approach, I think the terminology \emph{source}/\emph{target} models and
  transforming in \emph{forward} or \emph{backward} direction is at odds.
  FunnyQT speaks of a left and a right model and transforms in the direction of
  either of those.}.

Such a transformation definition gets compiled to a plain Clojure function
which receives the left and the right models, then an additional argument
denoting the direction in which the transformation is to be executed, and then
any additional arguments the transformation might declare (none in the
example).  Thus, it can simply be executed like shown in the next listing.

\begin{clojurecode}
(something2anything my-left-model my-right-model :right)
;; Valid directions:
;; :right: enforce in the direction of the right model
;; :left:  enforce in the direction of the left model
;; :right-checkonly: check if the right model corresponds to the left
;;         Returns trace information for any t-relation showing both
;;         elements that could and could not be related to elements
;;         in the other model.
;; :right-checkonly: check if the left model corresponds to the right
\end{clojurecode}

A bidirectional transformation consists of named transformation relations which
define correlations between elements in the left model and elements in the
right model using a \code|:left| and a \code|right| clause, each being a vector
of relational goals forming an implicit conjunction.  All goals have to succeed
for a valid correlation to be established.

\begin{clojurecode}
  (any2some
   :left  [(s/Some st ?some)
           (s/name st ?some ?value)]
   :right [(a/Any at ?any)
           (a/name at ?any ?value)])
\end{clojurecode}

The \code|any2some| transformation relation describes that an element
\code|?some| of type \code|Some| in the left model corresponds to an element
\code|?any| of type \code|Any| in the right model in case the \code|name|
attribute of both elements has the same \code|?value|.  In a transformation
relation, all logic variables are prefixed with a question mark.  The variables
\code|st| and \code|at| aren't because they are the transformation's input
arguments, the left and the right model.

Transformation relations have a forall-there-exists semantics, i.e., when the
example transformation is enforced in the direction of the right model, it
ensures that for every \code|Some| element there will be an \code|Any| element
with the same name.  If there are multiple \code|Some| elements with the same
name, then just one \code|Any| element with that name will suffice.

Transformation relations may also have preconditions defined as a \code|:when|
clause.  Like \code|:left| and \code|:right|, it is a vector of relational
goals forming a conjunction.  However, whereas either the \code|:left| or
\code|:right| clause may lead to creation or modification of elements depending
on the direction the transformation is executed in, the \code|:when| clause is
always exectued in check-only mode.  It is a typical place to define goals
which query the transformation's trace model or perform computations on plain
values like translating between ages and years of birth.

To define the control flow inside a transformation, there are two mechanisms
available.  First, at least one t-relation must be annotated with \code|^:top|
metadata.  These are executed implicitly in declaration order.  Secondly, a
t-relation may have a \code|:where| clause containing arbitrary code.  Usually,
this clause is used to call other t-relations with elements matched or created
by the calling t-relation.

The FunnyQT bidirectional transformation DSL has many more features not
discussed in this short intro like inheritance between transformations and
extension of t-relations.  Some of them are used and described in the actual
transformation below.  For the others, refer to \cite{diss} and the
documentation linked from \url{http://funnyqt.org}.


\subsection{The Families to Persons Transformation}
\label{sec:f2p-solution}

In this section, the actual FunnyQT transformation is going to be discussed.
As a first step, relational querying APIs for the two metamodels are generated.

\begin{clojurecode*}{linenos=true}
(rel/generate-metamodel-relations "metamodels/Families.ecore" f)
(rel/generate-metamodel-relations "metamodels/Persons.ecore" p)
\end{clojurecode*}

This makes the relations for the families metamodel available with the
namespace alias \code|f| and those of the persons metamodel with alias
\code|p|.

Next, we define some helper relation which defines the possible kinds of
relationships between a \code|family| and a family \code|member| depending on
if we prefer to create parents over creating children (parameter
\code|pref-parent|).  This is a higher-order relation in that the two remaining
parameters are a parent relation \code|prel| (either \code|f/->father| or
\code|f/->mother| has to be given) and a child relation (either
\code|f/->daughters| or \code|f/->sons| has to be given).

\begin{clojurecode*}{linenos=true,firstnumber=last}
(defn relationshipo [pref-parent f family member prel crel]
  (ccl/conda
   [(ccl/all
     (ccl/conda
      [(ccl/== pref-parent true)]
      [(bx/target-directiono :right)])
     (bx/unseto? f family prel member)
     (prel f family member))]
   [(crel f family member)]))
\end{clojurecode*}

\code|ccl/conda| is like an short-cutting logical OR.  The \(n\)-th clause is
only tried if all preceeding clauses fail\footnote{In contrast to
  \code|ccl/conde| which gives every clause a chance to succeed.}.  The first
clause succeeds if we prefer creating parents or we transform in the direction
of the persons model\footnote{In this direction, the preference should have no
  effect.}, and the \code|family|'s parent reference is unset or already set to
\code|member|, and if \code|(prel f family member)| succeeds which is the case
if \code|member| is already in the parent role of \code|family| or has been
assigned to this role just now.

In all other cases, \code|member| must be contained in the collection of
members in the children role denoted by \code|crel| of the \code|family|.

In the following, the actual transformation definition is explained.  It starts
with the following.

\begin{clojurecode*}{linenos=true,firstnumber=last}
(bx/deftransformation families2persons [f p prefer-parent prefer-ex-family]
  :delete-unmatched-target-elements true
  :id-init-fn bx/number-all-source-model-elements
\end{clojurecode*}

The transformation's name is \code|families2persons| and it declares four
parameters.  The parameter \code|f| is the family model (the left model),
\code|p| is the persons model (the right model), \code|prefer-parent| is a
boolean flag determining if we prefer creating parents to creating children,
and \code|prefer-ex-family| is a boolean flag, too, determining if we prefer
re-using existing families over creating new families for new family members.

By default, bidirectional FunnyQT transformations will never delete elements
from the current target model, i.e., the model in whose direction the
synchronization is performed.  The reason for that behavior is that it allows
to run the transformation first in one direction and then in the other
direction in order to perform a full synchronization where missing elements are
created in each of the two models.  Thus, after running a transformation, e.g.,
in the direction of the right model, it is only ensured that for each element
(considered by the transformation's rules), there is a corresponding
counterpart in the right model.  However, the right model might still contain
elements which have no counterpart in the left model.  With option
\code|:delete-unmatched-target-elements|set to \code|true|, this behavior is
changed.  Elements in the current target model which are not required by the
current source model and the transformation relations are deleted.

The next option, \code|:id-init-fn|, has the following purpose.  In this
transformation case, family members and persons don't have some kind of unique
identity.  For example, it is allowed to have two members named Jim with the
same name in the very same family Smith.  With FunnyQT BX transformations'
forall-there-exists semantics, it would suffice to create just one person in
the right model with the name set to ``Smith, Jim''.  However, the case
description mandates that we create one person for every member and vice versa,
no matter if they can be distinguished based on their attribute values.  For
such scenarios, FunnyQT's bidirectional transformation DSL provides a concept
of synthetic ID attributes.  The value of \code|:id-init-fn| has to be a
function which returns a map from elements to their synthetic IDs.  The
built-in function \code|bx/number-all-source-model-elements| returns a map
where every element in the source model gets assigned a unique integer number.
These synthetic IDs are then used in a transformation relation which is
discussed further below.

The first transformation relation, \code|family-register2person-register|,
transforms between family and person registers.

\begin{clojurecode*}{linenos=true,firstnumber=last}
  (^:top family-register2person-register
   :left  [(f/FamilyRegister f ?family-register)]
   :right [(p/PersonRegister p ?person-register)]
   :where [(member2female :?family-register ?family-register
                          :?person-register ?person-register)
           (member2male :?family-register ?family-register
                        :?person-register ?person-register)])
\end{clojurecode*}

It is defined as a top-level rule meaning that it'll be executed as the
transformation's entry point.  It's \code|:left| and \code|:right| clauses
describe that for every \code|?family-register| there has to be a
\code|?person-register| and vice versa.  We assume that there's always just one
register in each model.

The \code|:where| clause defines that after this relation has been enforced (or
checked in checkonly mode), then the two transformation relations
\code|member2female| and \code|member2male| have to be enforced (or tested)
between the current \code|?family-register| and
\code|?person-register|\footnote{Transformation relations are called with
  keyword parameters.  These calls say that the current \code|?family-register|
  will be bound to the logic variable with the same name in the called
  relation.}.

\begin{clojurecode*}{linenos=true,firstnumber=last}
  (^:abstract member2person
   :when  [(rel/stro ?last-name ", " ?first-name ?n)]
   :left  [(f/Family f ?family)
           (f/name f ?family ?last-name)
           (f/->families f ?family-register ?family)
           (f/FamilyMember f ?member)
           (f/name f ?member ?first-name)
           (id ?member ?id)
           (ccl/conda
            [(ccl/conde
              [(ccl/== prefer-ex-family true)]
              [(bx/existing-elemento? ?member)])]
            [(id ?family ?id)])]
   :right [(p/->persons p ?person-register ?person)
           (p/Person p ?person)
           (p/name p ?person ?n)
           (id ?person ?id)])
\end{clojurecode*}


\subsection{Gluing the Solution with the Framework}
\label{sec:gluing}

Typically, open-source Clojure libraries and programs are distributed as JAR
files that contain the source files rather than byte-compiled class files.
This solution does the same, and that JAR is deployed to a local Maven
repository from which the Maven build infrastructure of the benchmark framework
can pick it up.



\section{Evaluation \& Conclusion}
\label{sec:evaluation}



\bibliographystyle{alpha}
\bibliography{ttc17-funnyqt-solution}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-command-extra-options: "-shell-escape"
%%% LaTeX-verbatim-macros-with-delims-local: ("code")
%%% End:

%  LocalWords:  parallelizes
